/* tslint:disable */
/* eslint-disable */
/**
 * UAPI
 * UAPI 官方接口文档
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  GetClipzyGet200Response,
  GetClipzyGet400Response,
  GetClipzyGet404Response,
  GetClipzyRaw400Response,
  GetClipzyRaw403Response,
  PostClipzyStore200Response,
  PostClipzyStore400Response,
  PostClipzyStore413Response,
  PostClipzyStoreRequest,
} from '../models/index';
import {
    GetClipzyGet200ResponseFromJSON,
    GetClipzyGet200ResponseToJSON,
    GetClipzyGet400ResponseFromJSON,
    GetClipzyGet400ResponseToJSON,
    GetClipzyGet404ResponseFromJSON,
    GetClipzyGet404ResponseToJSON,
    GetClipzyRaw400ResponseFromJSON,
    GetClipzyRaw400ResponseToJSON,
    GetClipzyRaw403ResponseFromJSON,
    GetClipzyRaw403ResponseToJSON,
    PostClipzyStore200ResponseFromJSON,
    PostClipzyStore200ResponseToJSON,
    PostClipzyStore400ResponseFromJSON,
    PostClipzyStore400ResponseToJSON,
    PostClipzyStore413ResponseFromJSON,
    PostClipzyStore413ResponseToJSON,
    PostClipzyStoreRequestFromJSON,
    PostClipzyStoreRequestToJSON,
} from '../models/index';

export interface GetClipzyGetRequest {
    id: string;
}

export interface GetClipzyRawRequest {
    id: string;
    key: string;
}

export interface PostClipzyStoreOperationRequest {
    postClipzyStoreRequest: PostClipzyStoreRequest;
}

/**
 * 
 */
export class ClipzyApi extends runtime.BaseAPI {

    /**
     * **此接口用于“最高安全等级”方法。**  您提供第一步中获得的ID，它会返回存储在服务器上的**加密数据**。您需要在自己的客户端中，使用您自己保管的密钥来解密它。
     * 步骤2 (方法一): 获取加密数据
     */
    async getClipzyGetRaw(requestParameters: GetClipzyGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetClipzyGet200Response>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling getClipzyGet().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['id'] != null) {
            queryParameters['id'] = requestParameters['id'];
        }

        const headerParameters: runtime.HTTPHeaders = {};


        let urlPath = `/api/get`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GetClipzyGet200ResponseFromJSON(jsonValue));
    }

    /**
     * **此接口用于“最高安全等级”方法。**  您提供第一步中获得的ID，它会返回存储在服务器上的**加密数据**。您需要在自己的客户端中，使用您自己保管的密钥来解密它。
     * 步骤2 (方法一): 获取加密数据
     */
    async getClipzyGet(requestParameters: GetClipzyGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetClipzyGet200Response> {
        const response = await this.getClipzyGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * **此接口用于“方便自动化”方法。**  您提供第一步获得的ID，并附上您自己保管的**解密密钥**作为 `key` 参数。服务器会直接为您解密，并返回纯文本内容。  > [!IMPORTANT] > 查看文档首页的 **cURL 示例**，了解此接口最典型的用法。
     * 步骤2 (方法二): 获取原始文本
     */
    async getClipzyRawRaw(requestParameters: GetClipzyRawRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<string>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling getClipzyRaw().'
            );
        }

        if (requestParameters['key'] == null) {
            throw new runtime.RequiredError(
                'key',
                'Required parameter "key" was null or undefined when calling getClipzyRaw().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['key'] != null) {
            queryParameters['key'] = requestParameters['key'];
        }

        const headerParameters: runtime.HTTPHeaders = {};


        let urlPath = `/api/raw/{id}`;
        urlPath = urlPath.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<string>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * **此接口用于“方便自动化”方法。**  您提供第一步获得的ID，并附上您自己保管的**解密密钥**作为 `key` 参数。服务器会直接为您解密，并返回纯文本内容。  > [!IMPORTANT] > 查看文档首页的 **cURL 示例**，了解此接口最典型的用法。
     * 步骤2 (方法二): 获取原始文本
     */
    async getClipzyRaw(requestParameters: GetClipzyRawRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<string> {
        const response = await this.getClipzyRawRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * 这是所有流程的第一步。您的客户端应用需要先在本地准备好 **加密后的数据**，然后调用此接口进行上传。成功后，您会得到一个用于后续操作的唯一ID。  > [!NOTE] > 您发送给此接口的应该是**密文**，而不是原始文本。请参考文档首页的JavaScript示例来了解如何在客户端进行加密。
     * 步骤1：上传加密数据
     */
    async postClipzyStoreRaw(requestParameters: PostClipzyStoreOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PostClipzyStore200Response>> {
        if (requestParameters['postClipzyStoreRequest'] == null) {
            throw new runtime.RequiredError(
                'postClipzyStoreRequest',
                'Required parameter "postClipzyStoreRequest" was null or undefined when calling postClipzyStore().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';


        let urlPath = `/api/store`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: PostClipzyStoreRequestToJSON(requestParameters['postClipzyStoreRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PostClipzyStore200ResponseFromJSON(jsonValue));
    }

    /**
     * 这是所有流程的第一步。您的客户端应用需要先在本地准备好 **加密后的数据**，然后调用此接口进行上传。成功后，您会得到一个用于后续操作的唯一ID。  > [!NOTE] > 您发送给此接口的应该是**密文**，而不是原始文本。请参考文档首页的JavaScript示例来了解如何在客户端进行加密。
     * 步骤1：上传加密数据
     */
    async postClipzyStore(requestParameters: PostClipzyStoreOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PostClipzyStore200Response> {
        const response = await this.postClipzyStoreRaw(requestParameters, initOverrides);
        return await response.value();
    }

}
