/* tslint:disable */
/* eslint-disable */
/**
 * UAPI
 * UAPI 官方接口文档
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  GetAvatarGravatar400Response,
  GetAvatarGravatar404Response,
  GetImageBingDaily502Response,
  GetImageMotou400Response,
  GetImageMotou500Response,
  GetImageQrcode200Response,
  GetImageQrcode400Response,
  GetImageQrcode500Response,
  GetImageTobase64200Response,
  GetImageTobase64400Response,
  GetImageTobase64502Response,
  PostImageCompress400Response,
  PostImageCompress500Response,
  PostImageFrombase64200Response,
  PostImageFrombase64400Response,
  PostImageFrombase64500Response,
  PostImageFrombase64Request,
  PostImageMotou400Response,
  PostImageMotou500Response,
  PostImageSpeechless400Response,
  PostImageSpeechless500Response,
  PostImageSpeechlessRequest,
  PostImageSvg400Response,
  PostImageSvg500Response,
} from '../models/index';
import {
    GetAvatarGravatar400ResponseFromJSON,
    GetAvatarGravatar400ResponseToJSON,
    GetAvatarGravatar404ResponseFromJSON,
    GetAvatarGravatar404ResponseToJSON,
    GetImageBingDaily502ResponseFromJSON,
    GetImageBingDaily502ResponseToJSON,
    GetImageMotou400ResponseFromJSON,
    GetImageMotou400ResponseToJSON,
    GetImageMotou500ResponseFromJSON,
    GetImageMotou500ResponseToJSON,
    GetImageQrcode200ResponseFromJSON,
    GetImageQrcode200ResponseToJSON,
    GetImageQrcode400ResponseFromJSON,
    GetImageQrcode400ResponseToJSON,
    GetImageQrcode500ResponseFromJSON,
    GetImageQrcode500ResponseToJSON,
    GetImageTobase64200ResponseFromJSON,
    GetImageTobase64200ResponseToJSON,
    GetImageTobase64400ResponseFromJSON,
    GetImageTobase64400ResponseToJSON,
    GetImageTobase64502ResponseFromJSON,
    GetImageTobase64502ResponseToJSON,
    PostImageCompress400ResponseFromJSON,
    PostImageCompress400ResponseToJSON,
    PostImageCompress500ResponseFromJSON,
    PostImageCompress500ResponseToJSON,
    PostImageFrombase64200ResponseFromJSON,
    PostImageFrombase64200ResponseToJSON,
    PostImageFrombase64400ResponseFromJSON,
    PostImageFrombase64400ResponseToJSON,
    PostImageFrombase64500ResponseFromJSON,
    PostImageFrombase64500ResponseToJSON,
    PostImageFrombase64RequestFromJSON,
    PostImageFrombase64RequestToJSON,
    PostImageMotou400ResponseFromJSON,
    PostImageMotou400ResponseToJSON,
    PostImageMotou500ResponseFromJSON,
    PostImageMotou500ResponseToJSON,
    PostImageSpeechless400ResponseFromJSON,
    PostImageSpeechless400ResponseToJSON,
    PostImageSpeechless500ResponseFromJSON,
    PostImageSpeechless500ResponseToJSON,
    PostImageSpeechlessRequestFromJSON,
    PostImageSpeechlessRequestToJSON,
    PostImageSvg400ResponseFromJSON,
    PostImageSvg400ResponseToJSON,
    PostImageSvg500ResponseFromJSON,
    PostImageSvg500ResponseToJSON,
} from '../models/index';

export interface GetAvatarGravatarRequest {
    email?: string;
    hash?: string;
    s?: number;
    d?: string;
    r?: string;
}

export interface GetImageMotouRequest {
    qq: string;
    bgColor?: GetImageMotouBgColorEnum;
}

export interface GetImageQrcodeRequest {
    text: string;
    size?: number;
    format?: GetImageQrcodeFormatEnum;
}

export interface GetImageTobase64Request {
    url: string;
}

export interface PostImageCompressRequest {
    file: Blob;
    level?: PostImageCompressLevelEnum;
    format?: PostImageCompressFormatEnum;
}

export interface PostImageFrombase64OperationRequest {
    postImageFrombase64Request: PostImageFrombase64Request;
}

export interface PostImageMotouRequest {
    imageUrl?: string;
    file?: Blob;
    bgColor?: PostImageMotouBgColorEnum;
}

export interface PostImageSpeechlessOperationRequest {
    postImageSpeechlessRequest: PostImageSpeechlessRequest;
}

export interface PostImageSvgRequest {
    format?: PostImageSvgFormatEnum;
    width?: number;
    height?: number;
    quality?: number;
    file?: Blob;
}

/**
 * 
 */
export class ImageApi extends runtime.BaseAPI {

    /**
     * 提供一个超高速、高可用的Gravatar头像代理服务。内置了强大的ETag条件缓存，确保用户在更新Gravatar头像后能几乎立刻看到变化，同时最大化地利用缓存。
     * 获取Gravatar头像
     */
    async getAvatarGravatarRaw(requestParameters: GetAvatarGravatarRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Blob>> {
        const queryParameters: any = {};

        if (requestParameters['email'] != null) {
            queryParameters['email'] = requestParameters['email'];
        }

        if (requestParameters['hash'] != null) {
            queryParameters['hash'] = requestParameters['hash'];
        }

        if (requestParameters['s'] != null) {
            queryParameters['s'] = requestParameters['s'];
        }

        if (requestParameters['d'] != null) {
            queryParameters['d'] = requestParameters['d'];
        }

        if (requestParameters['r'] != null) {
            queryParameters['r'] = requestParameters['r'];
        }

        const headerParameters: runtime.HTTPHeaders = {};


        let urlPath = `/avatar/gravatar`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.BlobApiResponse(response);
    }

    /**
     * 提供一个超高速、高可用的Gravatar头像代理服务。内置了强大的ETag条件缓存，确保用户在更新Gravatar头像后能几乎立刻看到变化，同时最大化地利用缓存。
     * 获取Gravatar头像
     */
    async getAvatarGravatar(requestParameters: GetAvatarGravatarRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Blob> {
        const response = await this.getAvatarGravatarRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * 每天都想换张新壁纸？让必应的美图点亮你的一天吧！  ## 功能概述 这个接口会获取 Bing 搜索引擎当天全球同步的每日壁纸，并直接以图片形式返回。你可以用它来做应用的启动页、网站背景，或者任何需要每日更新精美图片的地方。  ## 使用须知  > [!NOTE] > **响应格式是图片** > 请注意，此接口成功时直接返回图片二进制数据（通常为 `image/jpeg`），而非 JSON 格式。请确保客户端能够正确处理。  我们内置了备用方案：如果从必应官方获取图片失败，系统会尝试返回一张预存的高质量风景图，以保证服务的稳定性。
     * 获取必应每日壁纸
     */
    async getImageBingDailyRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Blob>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};


        let urlPath = `/image/bing-daily`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.BlobApiResponse(response);
    }

    /**
     * 每天都想换张新壁纸？让必应的美图点亮你的一天吧！  ## 功能概述 这个接口会获取 Bing 搜索引擎当天全球同步的每日壁纸，并直接以图片形式返回。你可以用它来做应用的启动页、网站背景，或者任何需要每日更新精美图片的地方。  ## 使用须知  > [!NOTE] > **响应格式是图片** > 请注意，此接口成功时直接返回图片二进制数据（通常为 `image/jpeg`），而非 JSON 格式。请确保客户端能够正确处理。  我们内置了备用方案：如果从必应官方获取图片失败，系统会尝试返回一张预存的高质量风景图，以保证服务的稳定性。
     * 获取必应每日壁纸
     */
    async getImageBingDaily(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Blob> {
        const response = await this.getImageBingDailyRaw(initOverrides);
        return await response.value();
    }

    /**
     * 想在线rua一下好友的头像吗？这个趣味接口可以满足你。  ## 功能概述 此接口通过GET方法，专门用于通过QQ号生成摸摸头GIF。你只需要提供一个QQ号码，我们就会自动获取其公开头像，并制作成一个可爱的动图。  ## 使用须知 - **响应格式**：接口成功时直接返回 `image/gif` 格式的二进制数据。 - **背景颜色**：你可以通过 `bg_color` 参数来控制GIF的背景。使用 `transparent` 选项可以让它更好地融入各种聊天背景中。
     * 生成摸摸头GIF (QQ号方式)
     */
    async getImageMotouRaw(requestParameters: GetImageMotouRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Blob>> {
        if (requestParameters['qq'] == null) {
            throw new runtime.RequiredError(
                'qq',
                'Required parameter "qq" was null or undefined when calling getImageMotou().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['qq'] != null) {
            queryParameters['qq'] = requestParameters['qq'];
        }

        if (requestParameters['bgColor'] != null) {
            queryParameters['bg_color'] = requestParameters['bgColor'];
        }

        const headerParameters: runtime.HTTPHeaders = {};


        let urlPath = `/image/motou`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.BlobApiResponse(response);
    }

    /**
     * 想在线rua一下好友的头像吗？这个趣味接口可以满足你。  ## 功能概述 此接口通过GET方法，专门用于通过QQ号生成摸摸头GIF。你只需要提供一个QQ号码，我们就会自动获取其公开头像，并制作成一个可爱的动图。  ## 使用须知 - **响应格式**：接口成功时直接返回 `image/gif` 格式的二进制数据。 - **背景颜色**：你可以通过 `bg_color` 参数来控制GIF的背景。使用 `transparent` 选项可以让它更好地融入各种聊天背景中。
     * 生成摸摸头GIF (QQ号方式)
     */
    async getImageMotou(requestParameters: GetImageMotouRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Blob> {
        const response = await this.getImageMotouRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * 无论是网址、文本还是联系方式，通通可以变成一个二维码！这是一个非常灵活的二维码生成工具。  ## 功能概述 你提供一段文本内容，我们为你生成对应的二维码图片。你可以自定义尺寸，并选择不同的返回格式以适应不同场景。  ## 使用须知  > [!IMPORTANT] > **关键参数 `format`** > 此参数决定了成功响应的内容类型和结构，请务必根据你的需求选择并正确处理响应： > - **`image`** (默认): 直接返回 `image/png` 格式的图片二进制数据，适合在 `<img>` 标签中直接使用。 > - **`json`**: 返回一个包含 Base64 Data URI 的 JSON 对象，适合需要在前端直接嵌入CSS或HTML的场景。 > - **`json_url`**: 返回一个包含图片临时URL的JSON对象，适合需要图片链接的场景。
     * 动态生成二维码
     */
    async getImageQrcodeRaw(requestParameters: GetImageQrcodeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Blob>> {
        if (requestParameters['text'] == null) {
            throw new runtime.RequiredError(
                'text',
                'Required parameter "text" was null or undefined when calling getImageQrcode().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['text'] != null) {
            queryParameters['text'] = requestParameters['text'];
        }

        if (requestParameters['size'] != null) {
            queryParameters['size'] = requestParameters['size'];
        }

        if (requestParameters['format'] != null) {
            queryParameters['format'] = requestParameters['format'];
        }

        const headerParameters: runtime.HTTPHeaders = {};


        let urlPath = `/image/qrcode`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.BlobApiResponse(response);
    }

    /**
     * 无论是网址、文本还是联系方式，通通可以变成一个二维码！这是一个非常灵活的二维码生成工具。  ## 功能概述 你提供一段文本内容，我们为你生成对应的二维码图片。你可以自定义尺寸，并选择不同的返回格式以适应不同场景。  ## 使用须知  > [!IMPORTANT] > **关键参数 `format`** > 此参数决定了成功响应的内容类型和结构，请务必根据你的需求选择并正确处理响应： > - **`image`** (默认): 直接返回 `image/png` 格式的图片二进制数据，适合在 `<img>` 标签中直接使用。 > - **`json`**: 返回一个包含 Base64 Data URI 的 JSON 对象，适合需要在前端直接嵌入CSS或HTML的场景。 > - **`json_url`**: 返回一个包含图片临时URL的JSON对象，适合需要图片链接的场景。
     * 动态生成二维码
     */
    async getImageQrcode(requestParameters: GetImageQrcodeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Blob> {
        const response = await this.getImageQrcodeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * 看到一张网上的图片，想把它转换成 Base64 编码以便嵌入到你的 HTML 或 CSS 中？用这个接口就对了。  ## 功能概述 你提供一个公开可访问的图片 URL，我们帮你把它下载下来，并转换成包含 MIME 类型的 Base64 Data URI 字符串返回给你。
     * 将在线图片转换为Base64
     */
    async getImageTobase64Raw(requestParameters: GetImageTobase64Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetImageTobase64200Response>> {
        if (requestParameters['url'] == null) {
            throw new runtime.RequiredError(
                'url',
                'Required parameter "url" was null or undefined when calling getImageTobase64().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['url'] != null) {
            queryParameters['url'] = requestParameters['url'];
        }

        const headerParameters: runtime.HTTPHeaders = {};


        let urlPath = `/image/tobase64`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GetImageTobase64200ResponseFromJSON(jsonValue));
    }

    /**
     * 看到一张网上的图片，想把它转换成 Base64 编码以便嵌入到你的 HTML 或 CSS 中？用这个接口就对了。  ## 功能概述 你提供一个公开可访问的图片 URL，我们帮你把它下载下来，并转换成包含 MIME 类型的 Base64 Data URI 字符串返回给你。
     * 将在线图片转换为Base64
     */
    async getImageTobase64(requestParameters: GetImageTobase64Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetImageTobase64200Response> {
        const response = await this.getImageTobase64Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * 还在为图片体积和加载速度发愁吗？体验一下我们强大的**无损压缩服务**，它能在几乎不牺牲任何肉眼可感知的画质的前提下，将图片体积压缩到极致。  ## 功能概述 你只需要上传一张常见的图片（如 PNG, JPG），选择一个压缩等级，就能获得一个体积小到惊人的压缩文件。这对于需要大量展示高清图片的网站、App 或小程序来说，是优化用户体验、节省带宽和存储成本的利器。  ## 使用须知 > [!TIP] > 为了给您最好的压缩效果，我们的算法需要进行复杂计算，处理时间可能会稍长一些，请耐心等待。  > [!WARNING] > **服务排队提醒** > 这是一个计算密集型服务。在高并发时，您的请求可能会被排队等待处理。如果您需要将其集成到对延迟敏感的生产服务中，请注意这一点。  ### 请求与响应格式 - 请求必须使用 `multipart/form-data` 格式上传文件。 - 成功响应将直接返回压缩后的文件二进制流 (`application/octet-stream`)，并附带 `Content-Disposition` 头，建议客户端根据此头信息保存文件。  ## 参数详解 ### `level` (压缩等级) 这是一个从 `1` 到 `5` 的整数，它决定了压缩的强度和策略，数字越小，压缩率越高。所有等级都经过精心调校，以在最大化压缩率的同时保证出色的视觉质量。 - `1`: **极限压缩** (推荐，体积最小，画质优异) - `2`: **高效压缩** - `3`: **智能均衡** (默认选项) - `4`: **画质优先** - `5`: **专业保真** (压缩率稍低，保留最多图像信息)  ## 错误处理指南 - **400 Bad Request**: 通常因为没有上传文件，或者 `level` 参数不在 1-5 的范围内。 - **500 Internal Server Error**: 如果在压缩过程中服务器发生内部错误，会返回此状态码。
     * 无损压缩图片
     */
    async postImageCompressRaw(requestParameters: PostImageCompressRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Blob>> {
        if (requestParameters['file'] == null) {
            throw new runtime.RequiredError(
                'file',
                'Required parameter "file" was null or undefined when calling postImageCompress().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['level'] != null) {
            queryParameters['level'] = requestParameters['level'];
        }

        if (requestParameters['format'] != null) {
            queryParameters['format'] = requestParameters['format'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const consumes: runtime.Consume[] = [
            { contentType: 'multipart/form-data' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        // use FormData to transmit files using content-type "multipart/form-data"
        useForm = canConsumeForm;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters['file'] != null) {
            formParams.append('file', requestParameters['file'] as any);
        }


        let urlPath = `/image/compress`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        }, initOverrides);

        return new runtime.BlobApiResponse(response);
    }

    /**
     * 还在为图片体积和加载速度发愁吗？体验一下我们强大的**无损压缩服务**，它能在几乎不牺牲任何肉眼可感知的画质的前提下，将图片体积压缩到极致。  ## 功能概述 你只需要上传一张常见的图片（如 PNG, JPG），选择一个压缩等级，就能获得一个体积小到惊人的压缩文件。这对于需要大量展示高清图片的网站、App 或小程序来说，是优化用户体验、节省带宽和存储成本的利器。  ## 使用须知 > [!TIP] > 为了给您最好的压缩效果，我们的算法需要进行复杂计算，处理时间可能会稍长一些，请耐心等待。  > [!WARNING] > **服务排队提醒** > 这是一个计算密集型服务。在高并发时，您的请求可能会被排队等待处理。如果您需要将其集成到对延迟敏感的生产服务中，请注意这一点。  ### 请求与响应格式 - 请求必须使用 `multipart/form-data` 格式上传文件。 - 成功响应将直接返回压缩后的文件二进制流 (`application/octet-stream`)，并附带 `Content-Disposition` 头，建议客户端根据此头信息保存文件。  ## 参数详解 ### `level` (压缩等级) 这是一个从 `1` 到 `5` 的整数，它决定了压缩的强度和策略，数字越小，压缩率越高。所有等级都经过精心调校，以在最大化压缩率的同时保证出色的视觉质量。 - `1`: **极限压缩** (推荐，体积最小，画质优异) - `2`: **高效压缩** - `3`: **智能均衡** (默认选项) - `4`: **画质优先** - `5`: **专业保真** (压缩率稍低，保留最多图像信息)  ## 错误处理指南 - **400 Bad Request**: 通常因为没有上传文件，或者 `level` 参数不在 1-5 的范围内。 - **500 Internal Server Error**: 如果在压缩过程中服务器发生内部错误，会返回此状态码。
     * 无损压缩图片
     */
    async postImageCompress(requestParameters: PostImageCompressRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Blob> {
        const response = await this.postImageCompressRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * 当你需要在前端处理完图片（比如裁剪、加滤镜后），不通过传统表单，而是直接上传图片的场景，这个接口就派上用场了。  ## 功能概述 你只需要将图片的 Base64 编码字符串发送过来，我们就会把它解码、保存为图片文件，并返回一个可供访问的公开 URL。  ## 使用须知  > [!IMPORTANT] > **关于 `imageData` 格式** > 你发送的 `imageData` 字符串必须是完整的 Base64 Data URI 格式，它需要包含 MIME 类型信息，例如 `data:image/png;base64,iVBORw0KGgo...`。缺少 `data:image/...;base64,` 前缀将导致解码失败。
     * 通过Base64编码上传图片
     */
    async postImageFrombase64Raw(requestParameters: PostImageFrombase64OperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PostImageFrombase64200Response>> {
        if (requestParameters['postImageFrombase64Request'] == null) {
            throw new runtime.RequiredError(
                'postImageFrombase64Request',
                'Required parameter "postImageFrombase64Request" was null or undefined when calling postImageFrombase64().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';


        let urlPath = `/image/frombase64`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: PostImageFrombase64RequestToJSON(requestParameters['postImageFrombase64Request']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PostImageFrombase64200ResponseFromJSON(jsonValue));
    }

    /**
     * 当你需要在前端处理完图片（比如裁剪、加滤镜后），不通过传统表单，而是直接上传图片的场景，这个接口就派上用场了。  ## 功能概述 你只需要将图片的 Base64 编码字符串发送过来，我们就会把它解码、保存为图片文件，并返回一个可供访问的公开 URL。  ## 使用须知  > [!IMPORTANT] > **关于 `imageData` 格式** > 你发送的 `imageData` 字符串必须是完整的 Base64 Data URI 格式，它需要包含 MIME 类型信息，例如 `data:image/png;base64,iVBORw0KGgo...`。缺少 `data:image/...;base64,` 前缀将导致解码失败。
     * 通过Base64编码上传图片
     */
    async postImageFrombase64(requestParameters: PostImageFrombase64OperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PostImageFrombase64200Response> {
        const response = await this.postImageFrombase64Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * 除了使用QQ头像，你还可以通过上传自己的图片或提供图片URL来制作独一无二的摸摸头GIF。  ## 功能概述 此接口通过POST方法，支持两种方式生成GIF： 1.  **图片URL**：在表单中提供 `image_url` 字段。 2.  **上传图片**：在表单中上传 `file` 文件。  ## 使用须知 - **响应格式**：接口成功时直接返回 `image/gif` 格式的二进制数据。 - **参数优先级**：如果同时提供了 `image_url` 和上传的 `file` 文件，系统将 **优先使用 `image_url`**。 - **背景颜色**：同样支持 `bg_color` 表单字段来控制GIF背景。
     * 生成摸摸头GIF (图片上传或URL方式)
     */
    async postImageMotouRaw(requestParameters: PostImageMotouRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Blob>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const consumes: runtime.Consume[] = [
            { contentType: 'multipart/form-data' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        // use FormData to transmit files using content-type "multipart/form-data"
        useForm = canConsumeForm;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters['imageUrl'] != null) {
            formParams.append('image_url', requestParameters['imageUrl'] as any);
        }

        if (requestParameters['file'] != null) {
            formParams.append('file', requestParameters['file'] as any);
        }

        if (requestParameters['bgColor'] != null) {
            formParams.append('bg_color', requestParameters['bgColor'] as any);
        }


        let urlPath = `/image/motou`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        }, initOverrides);

        return new runtime.BlobApiResponse(response);
    }

    /**
     * 除了使用QQ头像，你还可以通过上传自己的图片或提供图片URL来制作独一无二的摸摸头GIF。  ## 功能概述 此接口通过POST方法，支持两种方式生成GIF： 1.  **图片URL**：在表单中提供 `image_url` 字段。 2.  **上传图片**：在表单中上传 `file` 文件。  ## 使用须知 - **响应格式**：接口成功时直接返回 `image/gif` 格式的二进制数据。 - **参数优先级**：如果同时提供了 `image_url` 和上传的 `file` 文件，系统将 **优先使用 `image_url`**。 - **背景颜色**：同样支持 `bg_color` 表单字段来控制GIF背景。
     * 生成摸摸头GIF (图片上传或URL方式)
     */
    async postImageMotou(requestParameters: PostImageMotouRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Blob> {
        const response = await this.postImageMotouRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * 你们怎么不说话了？是不是都在偷偷玩Uapi，求求你们不要玩Uapi了  ## 效果展示 ![示例](https://uapis.cn/static/uploads/33580466897f1e5815296f235b582815.png)  ## 使用须知 - **响应格式**：接口成功时直接返回 `image/jpeg` 格式的二进制数据。 - **文字内容**：至少需要提供 `top_text`（上方文字）或 `bottom_text`（下方文字）之一。 - **梗图逻辑**：上方描述某个行为，下方通常以「们」开头表示劝阻，形成戏谑的对比效果。
     * 生成你们怎么不说话了表情包
     */
    async postImageSpeechlessRaw(requestParameters: PostImageSpeechlessOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Blob>> {
        if (requestParameters['postImageSpeechlessRequest'] == null) {
            throw new runtime.RequiredError(
                'postImageSpeechlessRequest',
                'Required parameter "postImageSpeechlessRequest" was null or undefined when calling postImageSpeechless().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';


        let urlPath = `/image/speechless`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: PostImageSpeechlessRequestToJSON(requestParameters['postImageSpeechlessRequest']),
        }, initOverrides);

        return new runtime.BlobApiResponse(response);
    }

    /**
     * 你们怎么不说话了？是不是都在偷偷玩Uapi，求求你们不要玩Uapi了  ## 效果展示 ![示例](https://uapis.cn/static/uploads/33580466897f1e5815296f235b582815.png)  ## 使用须知 - **响应格式**：接口成功时直接返回 `image/jpeg` 格式的二进制数据。 - **文字内容**：至少需要提供 `top_text`（上方文字）或 `bottom_text`（下方文字）之一。 - **梗图逻辑**：上方描述某个行为，下方通常以「们」开头表示劝阻，形成戏谑的对比效果。
     * 生成你们怎么不说话了表情包
     */
    async postImageSpeechless(requestParameters: PostImageSpeechlessOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Blob> {
        const response = await this.postImageSpeechlessRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * 需要将灵活的 SVG 矢量图形转换为常见的光栅图像格式吗？这个接口可以帮你轻松实现。  ## 功能概述 上传一个 SVG 文件，并指定目标格式（如 PNG、JPEG 等），接口将返回转换后的图像。你还可以调整输出图像的尺寸和（对于JPEG）压缩质量，以满足不同场景的需求。
     * SVG转图片
     */
    async postImageSvgRaw(requestParameters: PostImageSvgRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Blob>> {
        const queryParameters: any = {};

        if (requestParameters['format'] != null) {
            queryParameters['format'] = requestParameters['format'];
        }

        if (requestParameters['width'] != null) {
            queryParameters['width'] = requestParameters['width'];
        }

        if (requestParameters['height'] != null) {
            queryParameters['height'] = requestParameters['height'];
        }

        if (requestParameters['quality'] != null) {
            queryParameters['quality'] = requestParameters['quality'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const consumes: runtime.Consume[] = [
            { contentType: 'multipart/form-data' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        // use FormData to transmit files using content-type "multipart/form-data"
        useForm = canConsumeForm;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters['file'] != null) {
            formParams.append('file', requestParameters['file'] as any);
        }


        let urlPath = `/image/svg`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        }, initOverrides);

        return new runtime.BlobApiResponse(response);
    }

    /**
     * 需要将灵活的 SVG 矢量图形转换为常见的光栅图像格式吗？这个接口可以帮你轻松实现。  ## 功能概述 上传一个 SVG 文件，并指定目标格式（如 PNG、JPEG 等），接口将返回转换后的图像。你还可以调整输出图像的尺寸和（对于JPEG）压缩质量，以满足不同场景的需求。
     * SVG转图片
     */
    async postImageSvg(requestParameters: PostImageSvgRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Blob> {
        const response = await this.postImageSvgRaw(requestParameters, initOverrides);
        return await response.value();
    }

}

/**
 * @export
 */
export const GetImageMotouBgColorEnum = {
    White: 'white',
    Black: 'black',
    Transparent: 'transparent'
} as const;
export type GetImageMotouBgColorEnum = typeof GetImageMotouBgColorEnum[keyof typeof GetImageMotouBgColorEnum];
/**
 * @export
 */
export const GetImageQrcodeFormatEnum = {
    Image: 'image',
    Json: 'json',
    JsonUrl: 'json_url'
} as const;
export type GetImageQrcodeFormatEnum = typeof GetImageQrcodeFormatEnum[keyof typeof GetImageQrcodeFormatEnum];
/**
 * @export
 */
export const PostImageCompressLevelEnum = {
    NUMBER_1: 1,
    NUMBER_2: 2,
    NUMBER_3: 3,
    NUMBER_4: 4,
    NUMBER_5: 5
} as const;
export type PostImageCompressLevelEnum = typeof PostImageCompressLevelEnum[keyof typeof PostImageCompressLevelEnum];
/**
 * @export
 */
export const PostImageCompressFormatEnum = {
    Png: 'png',
    Jpeg: 'jpeg'
} as const;
export type PostImageCompressFormatEnum = typeof PostImageCompressFormatEnum[keyof typeof PostImageCompressFormatEnum];
/**
 * @export
 */
export const PostImageMotouBgColorEnum = {
    White: 'white',
    Black: 'black',
    Transparent: 'transparent'
} as const;
export type PostImageMotouBgColorEnum = typeof PostImageMotouBgColorEnum[keyof typeof PostImageMotouBgColorEnum];
/**
 * @export
 */
export const PostImageSvgFormatEnum = {
    Png: 'png',
    Jpeg: 'jpeg',
    Jpg: 'jpg',
    Gif: 'gif',
    Tiff: 'tiff',
    Bmp: 'bmp'
} as const;
export type PostImageSvgFormatEnum = typeof PostImageSvgFormatEnum[keyof typeof PostImageSvgFormatEnum];
