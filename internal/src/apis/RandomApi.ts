/* tslint:disable */
/* eslint-disable */
/**
 * UAPI
 * UAPI 官方接口文档
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  GetAnswerbookAsk200Response,
  GetAnswerbookAsk400Response,
  GetAnswerbookAsk500Response,
  GetRandomImage404Response,
  GetRandomImage500Response,
  GetRandomString200Response,
  GetRandomString400Response,
  GetRandomString500Response,
  PostAnswerbookAsk200Response,
  PostAnswerbookAskRequest,
} from '../models/index';
import {
    GetAnswerbookAsk200ResponseFromJSON,
    GetAnswerbookAsk200ResponseToJSON,
    GetAnswerbookAsk400ResponseFromJSON,
    GetAnswerbookAsk400ResponseToJSON,
    GetAnswerbookAsk500ResponseFromJSON,
    GetAnswerbookAsk500ResponseToJSON,
    GetRandomImage404ResponseFromJSON,
    GetRandomImage404ResponseToJSON,
    GetRandomImage500ResponseFromJSON,
    GetRandomImage500ResponseToJSON,
    GetRandomString200ResponseFromJSON,
    GetRandomString200ResponseToJSON,
    GetRandomString400ResponseFromJSON,
    GetRandomString400ResponseToJSON,
    GetRandomString500ResponseFromJSON,
    GetRandomString500ResponseToJSON,
    PostAnswerbookAsk200ResponseFromJSON,
    PostAnswerbookAsk200ResponseToJSON,
    PostAnswerbookAskRequestFromJSON,
    PostAnswerbookAskRequestToJSON,
} from '../models/index';

export interface GetAnswerbookAskRequest {
    question: string;
}

export interface GetRandomImageRequest {
    category?: GetRandomImageCategoryEnum;
    type?: GetRandomImageTypeEnum;
}

export interface GetRandomStringRequest {
    length?: number;
    type?: GetRandomStringTypeEnum;
}

export interface PostAnswerbookAskOperationRequest {
    postAnswerbookAskRequest: PostAnswerbookAskRequest;
}

/**
 * 
 */
export class RandomApi extends runtime.BaseAPI {

    /**
     * 想要获得人生问题的神秘答案吗？答案之书API提供了一个神奇8球风格的问答服务，你可以提问并获得随机的神秘答案。  ## 功能概述 通过向答案之书提问，你将获得一个充满智慧（或许）的随机答案。这个API支持通过查询参数或POST请求体两种方式提问。  ## 使用须知  > [!TIP] > **提问技巧** > - 提出明确的问题会获得更好的体验 > - 问题不能为空 > - 支持中文问题 > - 答案具有随机性，仅供娱乐参考
     * 答案之书
     */
    async getAnswerbookAskRaw(requestParameters: GetAnswerbookAskRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetAnswerbookAsk200Response>> {
        if (requestParameters['question'] == null) {
            throw new runtime.RequiredError(
                'question',
                'Required parameter "question" was null or undefined when calling getAnswerbookAsk().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['question'] != null) {
            queryParameters['question'] = requestParameters['question'];
        }

        const headerParameters: runtime.HTTPHeaders = {};


        let urlPath = `/answerbook/ask`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GetAnswerbookAsk200ResponseFromJSON(jsonValue));
    }

    /**
     * 想要获得人生问题的神秘答案吗？答案之书API提供了一个神奇8球风格的问答服务，你可以提问并获得随机的神秘答案。  ## 功能概述 通过向答案之书提问，你将获得一个充满智慧（或许）的随机答案。这个API支持通过查询参数或POST请求体两种方式提问。  ## 使用须知  > [!TIP] > **提问技巧** > - 提出明确的问题会获得更好的体验 > - 问题不能为空 > - 支持中文问题 > - 答案具有随机性，仅供娱乐参考
     * 答案之书
     */
    async getAnswerbookAsk(requestParameters: GetAnswerbookAskRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetAnswerbookAsk200Response> {
        const response = await this.getAnswerbookAskRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * 需要一张随机图片作为占位符或者背景吗？这个接口是你的不二之选。  ## 功能概述 这是一个非常简单的接口，它会从我们庞大的图库和精选外部图床中随机挑选一张图片，然后通过 302 重定向让你直接访问到它。这使得它可以非常方便地直接用在 HTML 的 `<img>` 标签中。  你可以通过 `/api/v1/random/image?category=acg&type=4k` 这样的请求获取由UapiPro服务器提供的图片，也可以通过 `/api/v1/random/image?category=ai_drawing` 获取由外部图床精选的图片。  如果你不提供任何 category 参数，程序会从所有图片（包括本地的和URL的）中随机抽取一张（**全局随机图片不包含ikun和AI绘画**）。  > [!TIP] > 如果你需要更精确地控制图片类型，请使用 `/image/random/{category}/{type}` 接口。  ### 支持的主类别与子类别 - **acg**（二次元动漫）     - pc     - mb - **外部图床精选/混合动漫**   - **landscape**: 风景图。   - **anime**: 混合了UapiPro服务器的acg和外部图床的general_anime分类下的图片。   - **pc_wallpaper**: 电脑壁纸。   - **mobile_wallpaper**: 手机壁纸。   - **general_anime**: 动漫图。   - **ai_drawing**: AI绘画。 - **其他分类**   - **bq**（表情包/趣图）     - eciyuan     - ikun     - xiongmao     - waiguoren     - maomao   - **furry**（福瑞）     - z4k     - szs8k     - s4k     - 4k  > [!NOTE] > 默认全局随机（未指定category参数）时，不会包含ikun和AI绘画（ai_drawing）类别的图片。 
     * 随机图片
     */
    async getRandomImageRaw(requestParameters: GetRandomImageRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Blob>> {
        const queryParameters: any = {};

        if (requestParameters['category'] != null) {
            queryParameters['category'] = requestParameters['category'];
        }

        if (requestParameters['type'] != null) {
            queryParameters['type'] = requestParameters['type'];
        }

        const headerParameters: runtime.HTTPHeaders = {};


        let urlPath = `/random/image`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.BlobApiResponse(response);
    }

    /**
     * 需要一张随机图片作为占位符或者背景吗？这个接口是你的不二之选。  ## 功能概述 这是一个非常简单的接口，它会从我们庞大的图库和精选外部图床中随机挑选一张图片，然后通过 302 重定向让你直接访问到它。这使得它可以非常方便地直接用在 HTML 的 `<img>` 标签中。  你可以通过 `/api/v1/random/image?category=acg&type=4k` 这样的请求获取由UapiPro服务器提供的图片，也可以通过 `/api/v1/random/image?category=ai_drawing` 获取由外部图床精选的图片。  如果你不提供任何 category 参数，程序会从所有图片（包括本地的和URL的）中随机抽取一张（**全局随机图片不包含ikun和AI绘画**）。  > [!TIP] > 如果你需要更精确地控制图片类型，请使用 `/image/random/{category}/{type}` 接口。  ### 支持的主类别与子类别 - **acg**（二次元动漫）     - pc     - mb - **外部图床精选/混合动漫**   - **landscape**: 风景图。   - **anime**: 混合了UapiPro服务器的acg和外部图床的general_anime分类下的图片。   - **pc_wallpaper**: 电脑壁纸。   - **mobile_wallpaper**: 手机壁纸。   - **general_anime**: 动漫图。   - **ai_drawing**: AI绘画。 - **其他分类**   - **bq**（表情包/趣图）     - eciyuan     - ikun     - xiongmao     - waiguoren     - maomao   - **furry**（福瑞）     - z4k     - szs8k     - s4k     - 4k  > [!NOTE] > 默认全局随机（未指定category参数）时，不会包含ikun和AI绘画（ai_drawing）类别的图片。 
     * 随机图片
     */
    async getRandomImage(requestParameters: GetRandomImageRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Blob> {
        const response = await this.getRandomImageRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * 无论是需要生成一个安全的随机密码、一个唯一的Token，还是一个简单的随机ID，这个接口都能满足你。  ## 功能概述 你可以精确地控制生成字符串的长度和字符集类型，非常灵活。  ## 使用须知  > [!TIP] > **字符集类型 `type` 详解** > 你可以通过 `type` 参数精确控制生成的字符集： > - **`numeric`**: 纯数字 (0-9) > - **`lower`**: 纯小写字母 (a-z) > - **`upper`**: 纯大写字母 (A-Z) > - **`alpha`**: 大小写字母 (a-zA-Z) > - **`alphanumeric`** (默认): 数字和大小写字母 (0-9a-zA-Z) > - **`hex`**: 十六进制字符 (0-9a-f)
     * 随机字符串
     */
    async getRandomStringRaw(requestParameters: GetRandomStringRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetRandomString200Response>> {
        const queryParameters: any = {};

        if (requestParameters['length'] != null) {
            queryParameters['length'] = requestParameters['length'];
        }

        if (requestParameters['type'] != null) {
            queryParameters['type'] = requestParameters['type'];
        }

        const headerParameters: runtime.HTTPHeaders = {};


        let urlPath = `/random/string`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GetRandomString200ResponseFromJSON(jsonValue));
    }

    /**
     * 无论是需要生成一个安全的随机密码、一个唯一的Token，还是一个简单的随机ID，这个接口都能满足你。  ## 功能概述 你可以精确地控制生成字符串的长度和字符集类型，非常灵活。  ## 使用须知  > [!TIP] > **字符集类型 `type` 详解** > 你可以通过 `type` 参数精确控制生成的字符集： > - **`numeric`**: 纯数字 (0-9) > - **`lower`**: 纯小写字母 (a-z) > - **`upper`**: 纯大写字母 (A-Z) > - **`alpha`**: 大小写字母 (a-zA-Z) > - **`alphanumeric`** (默认): 数字和大小写字母 (0-9a-zA-Z) > - **`hex`**: 十六进制字符 (0-9a-f)
     * 随机字符串
     */
    async getRandomString(requestParameters: GetRandomStringRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetRandomString200Response> {
        const response = await this.getRandomStringRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * 通过POST请求向答案之书提问并获得神秘答案。  ## 功能概述 与GET方式相同，但通过JSON请求体发送问题，适合在需要发送较长问题或希望避免URL编码问题的场景中使用。  ## 请求体格式 请求体必须是有效的JSON格式，包含question字段。
     * 答案之书 (POST)
     */
    async postAnswerbookAskRaw(requestParameters: PostAnswerbookAskOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PostAnswerbookAsk200Response>> {
        if (requestParameters['postAnswerbookAskRequest'] == null) {
            throw new runtime.RequiredError(
                'postAnswerbookAskRequest',
                'Required parameter "postAnswerbookAskRequest" was null or undefined when calling postAnswerbookAsk().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';


        let urlPath = `/answerbook/ask`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: PostAnswerbookAskRequestToJSON(requestParameters['postAnswerbookAskRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PostAnswerbookAsk200ResponseFromJSON(jsonValue));
    }

    /**
     * 通过POST请求向答案之书提问并获得神秘答案。  ## 功能概述 与GET方式相同，但通过JSON请求体发送问题，适合在需要发送较长问题或希望避免URL编码问题的场景中使用。  ## 请求体格式 请求体必须是有效的JSON格式，包含question字段。
     * 答案之书 (POST)
     */
    async postAnswerbookAsk(requestParameters: PostAnswerbookAskOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PostAnswerbookAsk200Response> {
        const response = await this.postAnswerbookAskRaw(requestParameters, initOverrides);
        return await response.value();
    }

}

/**
 * @export
 */
export const GetRandomImageCategoryEnum = {
    Acg: 'acg',
    Landscape: 'landscape',
    Anime: 'anime',
    PcWallpaper: 'pc_wallpaper',
    MobileWallpaper: 'mobile_wallpaper',
    GeneralAnime: 'general_anime',
    AiDrawing: 'ai_drawing',
    Bq: 'bq',
    Furry: 'furry'
} as const;
export type GetRandomImageCategoryEnum = typeof GetRandomImageCategoryEnum[keyof typeof GetRandomImageCategoryEnum];
/**
 * @export
 */
export const GetRandomImageTypeEnum = {
    Pc: 'pc',
    Mb: 'mb',
    Eciyuan: 'eciyuan',
    Ikun: 'ikun',
    _4k: '4k',
    S4k: 's4k',
    Z4k: 'z4k',
    Szs8k: 'szs8k',
    Xiongmao: 'xiongmao',
    Maomao: 'maomao',
    Waiguoren: 'waiguoren'
} as const;
export type GetRandomImageTypeEnum = typeof GetRandomImageTypeEnum[keyof typeof GetRandomImageTypeEnum];
/**
 * @export
 */
export const GetRandomStringTypeEnum = {
    Numeric: 'numeric',
    Lower: 'lower',
    Upper: 'upper',
    Alpha: 'alpha',
    Alphanumeric: 'alphanumeric',
    Hex: 'hex'
} as const;
export type GetRandomStringTypeEnum = typeof GetRandomStringTypeEnum[keyof typeof GetRandomStringTypeEnum];
