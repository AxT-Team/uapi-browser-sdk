/* tslint:disable */
/* eslint-disable */
/**
 * UAPI
 * UAPI 官方接口文档
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  GetImageTobase64400Response,
  GetNetworkDns200Response,
  GetNetworkDns400Response,
  GetNetworkDns404Response,
  GetNetworkIcp200Response,
  GetNetworkIcp404Response,
  GetNetworkIpinfo200Response,
  GetNetworkIpinfo400Response,
  GetNetworkIpinfo404Response,
  GetNetworkIpinfo500Response,
  GetNetworkMyip400Response,
  GetNetworkMyip500Response,
  GetNetworkPing200Response,
  GetNetworkPing400Response,
  GetNetworkPing429Response,
  GetNetworkPingmyip200Response,
  GetNetworkPingmyip404Response,
  GetNetworkPortscan200Response,
  GetNetworkPortscan400Response,
  GetNetworkPortscan500Response,
  GetNetworkUrlstatus200Response,
  GetNetworkUrlstatus502Response,
  GetNetworkWhois200Response,
  GetNetworkWhois404Response,
  GetNetworkWxdomain200Response,
  GetNetworkWxdomain502Response,
} from '../models/index';
import {
    GetImageTobase64400ResponseFromJSON,
    GetImageTobase64400ResponseToJSON,
    GetNetworkDns200ResponseFromJSON,
    GetNetworkDns200ResponseToJSON,
    GetNetworkDns400ResponseFromJSON,
    GetNetworkDns400ResponseToJSON,
    GetNetworkDns404ResponseFromJSON,
    GetNetworkDns404ResponseToJSON,
    GetNetworkIcp200ResponseFromJSON,
    GetNetworkIcp200ResponseToJSON,
    GetNetworkIcp404ResponseFromJSON,
    GetNetworkIcp404ResponseToJSON,
    GetNetworkIpinfo200ResponseFromJSON,
    GetNetworkIpinfo200ResponseToJSON,
    GetNetworkIpinfo400ResponseFromJSON,
    GetNetworkIpinfo400ResponseToJSON,
    GetNetworkIpinfo404ResponseFromJSON,
    GetNetworkIpinfo404ResponseToJSON,
    GetNetworkIpinfo500ResponseFromJSON,
    GetNetworkIpinfo500ResponseToJSON,
    GetNetworkMyip400ResponseFromJSON,
    GetNetworkMyip400ResponseToJSON,
    GetNetworkMyip500ResponseFromJSON,
    GetNetworkMyip500ResponseToJSON,
    GetNetworkPing200ResponseFromJSON,
    GetNetworkPing200ResponseToJSON,
    GetNetworkPing400ResponseFromJSON,
    GetNetworkPing400ResponseToJSON,
    GetNetworkPing429ResponseFromJSON,
    GetNetworkPing429ResponseToJSON,
    GetNetworkPingmyip200ResponseFromJSON,
    GetNetworkPingmyip200ResponseToJSON,
    GetNetworkPingmyip404ResponseFromJSON,
    GetNetworkPingmyip404ResponseToJSON,
    GetNetworkPortscan200ResponseFromJSON,
    GetNetworkPortscan200ResponseToJSON,
    GetNetworkPortscan400ResponseFromJSON,
    GetNetworkPortscan400ResponseToJSON,
    GetNetworkPortscan500ResponseFromJSON,
    GetNetworkPortscan500ResponseToJSON,
    GetNetworkUrlstatus200ResponseFromJSON,
    GetNetworkUrlstatus200ResponseToJSON,
    GetNetworkUrlstatus502ResponseFromJSON,
    GetNetworkUrlstatus502ResponseToJSON,
    GetNetworkWhois200ResponseFromJSON,
    GetNetworkWhois200ResponseToJSON,
    GetNetworkWhois404ResponseFromJSON,
    GetNetworkWhois404ResponseToJSON,
    GetNetworkWxdomain200ResponseFromJSON,
    GetNetworkWxdomain200ResponseToJSON,
    GetNetworkWxdomain502ResponseFromJSON,
    GetNetworkWxdomain502ResponseToJSON,
} from '../models/index';

export interface GetNetworkDnsRequest {
    domain: string;
    type?: GetNetworkDnsTypeEnum;
}

export interface GetNetworkIcpRequest {
    domain: string;
}

export interface GetNetworkIpinfoRequest {
    ip: string;
    source?: GetNetworkIpinfoSourceEnum;
}

export interface GetNetworkMyipRequest {
    source?: GetNetworkMyipSourceEnum;
}

export interface GetNetworkPingRequest {
    host: string;
}

export interface GetNetworkPortscanRequest {
    host: string;
    port: number;
    protocol?: GetNetworkPortscanProtocolEnum;
}

export interface GetNetworkUrlstatusRequest {
    url: string;
}

export interface GetNetworkWhoisRequest {
    domain: string;
    format?: GetNetworkWhoisFormatEnum;
}

export interface GetNetworkWxdomainRequest {
    domain: string;
}

/**
 * 
 */
export class NetworkApi extends runtime.BaseAPI {

    /**
     * 想知道一个域名指向了哪个IP？或者它的邮件服务器是谁？这个接口就像一个在线的 `dig` 或 `nslookup` 工具。  ## 功能概述 你可以查询指定域名的各种DNS记录，包括 `A` (IPv4), `AAAA` (IPv6), `CNAME` (别名), `MX` (邮件交换), `NS` (域名服务器) 和 `TXT` (文本记录)。
     * 执行DNS解析查询
     */
    async getNetworkDnsRaw(requestParameters: GetNetworkDnsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetNetworkDns200Response>> {
        if (requestParameters['domain'] == null) {
            throw new runtime.RequiredError(
                'domain',
                'Required parameter "domain" was null or undefined when calling getNetworkDns().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['domain'] != null) {
            queryParameters['domain'] = requestParameters['domain'];
        }

        if (requestParameters['type'] != null) {
            queryParameters['type'] = requestParameters['type'];
        }

        const headerParameters: runtime.HTTPHeaders = {};


        let urlPath = `/network/dns`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GetNetworkDns200ResponseFromJSON(jsonValue));
    }

    /**
     * 想知道一个域名指向了哪个IP？或者它的邮件服务器是谁？这个接口就像一个在线的 `dig` 或 `nslookup` 工具。  ## 功能概述 你可以查询指定域名的各种DNS记录，包括 `A` (IPv4), `AAAA` (IPv6), `CNAME` (别名), `MX` (邮件交换), `NS` (域名服务器) 和 `TXT` (文本记录)。
     * 执行DNS解析查询
     */
    async getNetworkDns(requestParameters: GetNetworkDnsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetNetworkDns200Response> {
        const response = await this.getNetworkDnsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * 想知道一个网站的背后运营主体是谁吗？如果它是在中国大陆运营的，ICP备案信息可以告诉你答案。  ## 功能概述 提供一个域名，查询其在中国工信部的ICP（Internet Content Provider）备案信息。这对于商业合作前的背景调查、验证网站合法性等场景很有帮助。  > [!NOTE] > **查询范围** > 此查询仅对在中国大陆工信部进行过备案的域名有效。对于国外域名或未备案的域名，将查询不到结果。
     * 查询域名ICP备案信息
     */
    async getNetworkIcpRaw(requestParameters: GetNetworkIcpRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetNetworkIcp200Response>> {
        if (requestParameters['domain'] == null) {
            throw new runtime.RequiredError(
                'domain',
                'Required parameter "domain" was null or undefined when calling getNetworkIcp().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['domain'] != null) {
            queryParameters['domain'] = requestParameters['domain'];
        }

        const headerParameters: runtime.HTTPHeaders = {};


        let urlPath = `/network/icp`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GetNetworkIcp200ResponseFromJSON(jsonValue));
    }

    /**
     * 想知道一个网站的背后运营主体是谁吗？如果它是在中国大陆运营的，ICP备案信息可以告诉你答案。  ## 功能概述 提供一个域名，查询其在中国工信部的ICP（Internet Content Provider）备案信息。这对于商业合作前的背景调查、验证网站合法性等场景很有帮助。  > [!NOTE] > **查询范围** > 此查询仅对在中国大陆工信部进行过备案的域名有效。对于国外域名或未备案的域名，将查询不到结果。
     * 查询域名ICP备案信息
     */
    async getNetworkIcp(requestParameters: GetNetworkIcpRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetNetworkIcp200Response> {
        const response = await this.getNetworkIcpRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * 想知道一个IP地址或域名来自地球的哪个角落？这个接口可以帮你定位它。你可以选择使用默认的GeoIP数据库，也可以指定 `source=commercial` 参数来查询更详细的商业级IP归属信息。  ## 功能概述 提供一个公网IPv4、IPv6地址或域名，我们会利用GeoIP数据库查询并返回它的地理位置（国家、省份、城市）、经纬度、以及所属的运营商（ISP）和自治系统（ASN）信息。这在网络安全分析、访问来源统计等领域非常有用。  当使用 `source=commercial` 参数时，接口将调用高性能商业API，提供更精确的市、区、运营商、时区、海拔等信息。请注意，商业查询的响应时间可能会稍长。
     * 查询指定IP或域名的归属信息
     */
    async getNetworkIpinfoRaw(requestParameters: GetNetworkIpinfoRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetNetworkIpinfo200Response>> {
        if (requestParameters['ip'] == null) {
            throw new runtime.RequiredError(
                'ip',
                'Required parameter "ip" was null or undefined when calling getNetworkIpinfo().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['ip'] != null) {
            queryParameters['ip'] = requestParameters['ip'];
        }

        if (requestParameters['source'] != null) {
            queryParameters['source'] = requestParameters['source'];
        }

        const headerParameters: runtime.HTTPHeaders = {};


        let urlPath = `/network/ipinfo`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GetNetworkIpinfo200ResponseFromJSON(jsonValue));
    }

    /**
     * 想知道一个IP地址或域名来自地球的哪个角落？这个接口可以帮你定位它。你可以选择使用默认的GeoIP数据库，也可以指定 `source=commercial` 参数来查询更详细的商业级IP归属信息。  ## 功能概述 提供一个公网IPv4、IPv6地址或域名，我们会利用GeoIP数据库查询并返回它的地理位置（国家、省份、城市）、经纬度、以及所属的运营商（ISP）和自治系统（ASN）信息。这在网络安全分析、访问来源统计等领域非常有用。  当使用 `source=commercial` 参数时，接口将调用高性能商业API，提供更精确的市、区、运营商、时区、海拔等信息。请注意，商业查询的响应时间可能会稍长。
     * 查询指定IP或域名的归属信息
     */
    async getNetworkIpinfo(requestParameters: GetNetworkIpinfoRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetNetworkIpinfo200Response> {
        const response = await this.getNetworkIpinfoRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * 想知道你自己的出口公网IP是多少吗？这个接口就是你的“网络身份证”。你可以选择使用默认的GeoIP数据库，也可以指定 `source=commercial` 参数来查询更详细的商业级IP归属信息。  ## 功能概述 调用此接口，它会返回你（即发起请求的客户端）的公网IP地址，并附带与 `/network/ipinfo` 接口相同的地理位置和网络归属信息。非常适合用于在网页上向用户展示他们自己的IP和地理位置。  当使用 `source=commercial` 参数时，接口将调用高性能商业API，提供更精确的市、区、运营商、时区、海拔等信息。请注意，商业查询的响应时间可能会稍长。
     * 获取你的公网IP及归属信息
     */
    async getNetworkMyipRaw(requestParameters: GetNetworkMyipRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetNetworkIpinfo200Response>> {
        const queryParameters: any = {};

        if (requestParameters['source'] != null) {
            queryParameters['source'] = requestParameters['source'];
        }

        const headerParameters: runtime.HTTPHeaders = {};


        let urlPath = `/network/myip`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GetNetworkIpinfo200ResponseFromJSON(jsonValue));
    }

    /**
     * 想知道你自己的出口公网IP是多少吗？这个接口就是你的“网络身份证”。你可以选择使用默认的GeoIP数据库，也可以指定 `source=commercial` 参数来查询更详细的商业级IP归属信息。  ## 功能概述 调用此接口，它会返回你（即发起请求的客户端）的公网IP地址，并附带与 `/network/ipinfo` 接口相同的地理位置和网络归属信息。非常适合用于在网页上向用户展示他们自己的IP和地理位置。  当使用 `source=commercial` 参数时，接口将调用高性能商业API，提供更精确的市、区、运营商、时区、海拔等信息。请注意，商业查询的响应时间可能会稍长。
     * 获取你的公网IP及归属信息
     */
    async getNetworkMyip(requestParameters: GetNetworkMyipRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetNetworkIpinfo200Response> {
        const response = await this.getNetworkMyipRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * 想知道从我们的服务器到你的服务器网络延迟高不高？这个工具可以帮你测试网络连通性。  ## 功能概述 这个接口会从我们的服务器节点对你指定的主机（域名或IP地址）执行 ICMP Ping 操作。它会返回最小、最大、平均延迟以及丢包率等关键指标，是诊断网络问题的得力助手。
     * 从服务器Ping指定主机
     */
    async getNetworkPingRaw(requestParameters: GetNetworkPingRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetNetworkPing200Response>> {
        if (requestParameters['host'] == null) {
            throw new runtime.RequiredError(
                'host',
                'Required parameter "host" was null or undefined when calling getNetworkPing().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['host'] != null) {
            queryParameters['host'] = requestParameters['host'];
        }

        const headerParameters: runtime.HTTPHeaders = {};


        let urlPath = `/network/ping`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GetNetworkPing200ResponseFromJSON(jsonValue));
    }

    /**
     * 想知道从我们的服务器到你的服务器网络延迟高不高？这个工具可以帮你测试网络连通性。  ## 功能概述 这个接口会从我们的服务器节点对你指定的主机（域名或IP地址）执行 ICMP Ping 操作。它会返回最小、最大、平均延迟以及丢包率等关键指标，是诊断网络问题的得力助手。
     * 从服务器Ping指定主机
     */
    async getNetworkPing(requestParameters: GetNetworkPingRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetNetworkPing200Response> {
        const response = await this.getNetworkPingRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * 这是一个非常方便的快捷接口，想知道你的网络到我们服务器的回程延迟吗？点一下就行！  ## 功能概述 这个接口是 `/network/myip` 和 `/network/ping` 的结合体。它会自动获取你客户端的公网IP，然后从我们的服务器Ping这个IP，并返回延迟数据。这对于快速判断你本地网络到服务器的连接质量非常有用。
     * 从服务器Ping你的客户端IP
     */
    async getNetworkPingmyipRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetNetworkPingmyip200Response>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};


        let urlPath = `/network/pingmyip`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GetNetworkPingmyip200ResponseFromJSON(jsonValue));
    }

    /**
     * 这是一个非常方便的快捷接口，想知道你的网络到我们服务器的回程延迟吗？点一下就行！  ## 功能概述 这个接口是 `/network/myip` 和 `/network/ping` 的结合体。它会自动获取你客户端的公网IP，然后从我们的服务器Ping这个IP，并返回延迟数据。这对于快速判断你本地网络到服务器的连接质量非常有用。
     * 从服务器Ping你的客户端IP
     */
    async getNetworkPingmyip(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetNetworkPingmyip200Response> {
        const response = await this.getNetworkPingmyipRaw(initOverrides);
        return await response.value();
    }

    /**
     * 想检查一下你的服务器上某个端口（比如SSH的22端口或者Web的80端口）是否对外开放？这个工具可以帮你快速确认。  ## 功能概述 你可以指定一个主机和端口号，我们的服务器会尝试连接该端口，并告诉你它是开放的（open）、关闭的（closed）还是超时了（timeout）。这对于网络服务配置检查和基本的安全扫描很有用。
     * 扫描远程主机的指定端口
     */
    async getNetworkPortscanRaw(requestParameters: GetNetworkPortscanRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetNetworkPortscan200Response>> {
        if (requestParameters['host'] == null) {
            throw new runtime.RequiredError(
                'host',
                'Required parameter "host" was null or undefined when calling getNetworkPortscan().'
            );
        }

        if (requestParameters['port'] == null) {
            throw new runtime.RequiredError(
                'port',
                'Required parameter "port" was null or undefined when calling getNetworkPortscan().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['host'] != null) {
            queryParameters['host'] = requestParameters['host'];
        }

        if (requestParameters['port'] != null) {
            queryParameters['port'] = requestParameters['port'];
        }

        if (requestParameters['protocol'] != null) {
            queryParameters['protocol'] = requestParameters['protocol'];
        }

        const headerParameters: runtime.HTTPHeaders = {};


        let urlPath = `/network/portscan`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GetNetworkPortscan200ResponseFromJSON(jsonValue));
    }

    /**
     * 想检查一下你的服务器上某个端口（比如SSH的22端口或者Web的80端口）是否对外开放？这个工具可以帮你快速确认。  ## 功能概述 你可以指定一个主机和端口号，我们的服务器会尝试连接该端口，并告诉你它是开放的（open）、关闭的（closed）还是超时了（timeout）。这对于网络服务配置检查和基本的安全扫描很有用。
     * 扫描远程主机的指定端口
     */
    async getNetworkPortscan(requestParameters: GetNetworkPortscanRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetNetworkPortscan200Response> {
        const response = await this.getNetworkPortscanRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * 你的网站或API还好吗？用这个接口给它做个快速“体检”吧。  ## 功能概述 提供一个URL，我们会向它发起一个请求，并返回其HTTP响应状态码。这是一种简单而有效的服务可用性监控方法。  > [!TIP] > **性能优化**：为了提高效率并减少对目标服务器的负载，我们实际发送的是 `HEAD` 请求，而不是 `GET` 请求。`HEAD` 请求只会获取响应头，而不会下载整个页面内容，因此速度更快。
     * 检查URL的可访问性状态
     */
    async getNetworkUrlstatusRaw(requestParameters: GetNetworkUrlstatusRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetNetworkUrlstatus200Response>> {
        if (requestParameters['url'] == null) {
            throw new runtime.RequiredError(
                'url',
                'Required parameter "url" was null or undefined when calling getNetworkUrlstatus().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['url'] != null) {
            queryParameters['url'] = requestParameters['url'];
        }

        const headerParameters: runtime.HTTPHeaders = {};


        let urlPath = `/network/urlstatus`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GetNetworkUrlstatus200ResponseFromJSON(jsonValue));
    }

    /**
     * 你的网站或API还好吗？用这个接口给它做个快速“体检”吧。  ## 功能概述 提供一个URL，我们会向它发起一个请求，并返回其HTTP响应状态码。这是一种简单而有效的服务可用性监控方法。  > [!TIP] > **性能优化**：为了提高效率并减少对目标服务器的负载，我们实际发送的是 `HEAD` 请求，而不是 `GET` 请求。`HEAD` 请求只会获取响应头，而不会下载整个页面内容，因此速度更快。
     * 检查URL的可访问性状态
     */
    async getNetworkUrlstatus(requestParameters: GetNetworkUrlstatusRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetNetworkUrlstatus200Response> {
        const response = await this.getNetworkUrlstatusRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * 想知道一个域名是什么时候注册的、注册商是谁、什么时候到期？WHOIS信息可以告诉你这一切。  ## 功能概述 这是一个在线的WHOIS查询工具。你可以通过如下两种方式获取WHOIS信息：  - **默认行为**（不带参数）：`GET /api/v1/network/whois?domain=google.com`   - 返回一个JSON对象，`whois` 字段为原始、未处理的WHOIS文本字符串。 - **JSON格式化**：`GET /api/v1/network/whois?domain=google.com&format=json`   - 返回一个JSON对象，`whois` 字段为解析后的JSON对象，包含WHOIS信息中的键值对。  这样你既可以获得最全的原始信息，也可以方便地处理结构化数据。
     * 查询域名的WHOIS注册信息
     */
    async getNetworkWhoisRaw(requestParameters: GetNetworkWhoisRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetNetworkWhois200Response>> {
        if (requestParameters['domain'] == null) {
            throw new runtime.RequiredError(
                'domain',
                'Required parameter "domain" was null or undefined when calling getNetworkWhois().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['domain'] != null) {
            queryParameters['domain'] = requestParameters['domain'];
        }

        if (requestParameters['format'] != null) {
            queryParameters['format'] = requestParameters['format'];
        }

        const headerParameters: runtime.HTTPHeaders = {};


        let urlPath = `/network/whois`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GetNetworkWhois200ResponseFromJSON(jsonValue));
    }

    /**
     * 想知道一个域名是什么时候注册的、注册商是谁、什么时候到期？WHOIS信息可以告诉你这一切。  ## 功能概述 这是一个在线的WHOIS查询工具。你可以通过如下两种方式获取WHOIS信息：  - **默认行为**（不带参数）：`GET /api/v1/network/whois?domain=google.com`   - 返回一个JSON对象，`whois` 字段为原始、未处理的WHOIS文本字符串。 - **JSON格式化**：`GET /api/v1/network/whois?domain=google.com&format=json`   - 返回一个JSON对象，`whois` 字段为解析后的JSON对象，包含WHOIS信息中的键值对。  这样你既可以获得最全的原始信息，也可以方便地处理结构化数据。
     * 查询域名的WHOIS注册信息
     */
    async getNetworkWhois(requestParameters: GetNetworkWhoisRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetNetworkWhois200Response> {
        const response = await this.getNetworkWhoisRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * 准备在微信里推广你的网站？最好先检查一下域名是否被“拉黑”了。  ## 功能概述 这个接口可以帮你查询一个域名在微信内置浏览器中的访问状态，即是否被微信封禁。这对于做微信生态推广和营销的开发者来说至关重要。
     * 检查域名在微信中的访问状态
     */
    async getNetworkWxdomainRaw(requestParameters: GetNetworkWxdomainRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetNetworkWxdomain200Response>> {
        if (requestParameters['domain'] == null) {
            throw new runtime.RequiredError(
                'domain',
                'Required parameter "domain" was null or undefined when calling getNetworkWxdomain().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['domain'] != null) {
            queryParameters['domain'] = requestParameters['domain'];
        }

        const headerParameters: runtime.HTTPHeaders = {};


        let urlPath = `/network/wxdomain`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GetNetworkWxdomain200ResponseFromJSON(jsonValue));
    }

    /**
     * 准备在微信里推广你的网站？最好先检查一下域名是否被“拉黑”了。  ## 功能概述 这个接口可以帮你查询一个域名在微信内置浏览器中的访问状态，即是否被微信封禁。这对于做微信生态推广和营销的开发者来说至关重要。
     * 检查域名在微信中的访问状态
     */
    async getNetworkWxdomain(requestParameters: GetNetworkWxdomainRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetNetworkWxdomain200Response> {
        const response = await this.getNetworkWxdomainRaw(requestParameters, initOverrides);
        return await response.value();
    }

}

/**
 * @export
 */
export const GetNetworkDnsTypeEnum = {
    A: 'A',
    Aaaa: 'AAAA',
    Cname: 'CNAME',
    Mx: 'MX',
    Ns: 'NS',
    Txt: 'TXT'
} as const;
export type GetNetworkDnsTypeEnum = typeof GetNetworkDnsTypeEnum[keyof typeof GetNetworkDnsTypeEnum];
/**
 * @export
 */
export const GetNetworkIpinfoSourceEnum = {
    Commercial: 'commercial'
} as const;
export type GetNetworkIpinfoSourceEnum = typeof GetNetworkIpinfoSourceEnum[keyof typeof GetNetworkIpinfoSourceEnum];
/**
 * @export
 */
export const GetNetworkMyipSourceEnum = {
    Commercial: 'commercial'
} as const;
export type GetNetworkMyipSourceEnum = typeof GetNetworkMyipSourceEnum[keyof typeof GetNetworkMyipSourceEnum];
/**
 * @export
 */
export const GetNetworkPortscanProtocolEnum = {
    Tcp: 'tcp',
    Udp: 'udp'
} as const;
export type GetNetworkPortscanProtocolEnum = typeof GetNetworkPortscanProtocolEnum[keyof typeof GetNetworkPortscanProtocolEnum];
/**
 * @export
 */
export const GetNetworkWhoisFormatEnum = {
    Text: 'text',
    Json: 'json'
} as const;
export type GetNetworkWhoisFormatEnum = typeof GetNetworkWhoisFormatEnum[keyof typeof GetNetworkWhoisFormatEnum];
